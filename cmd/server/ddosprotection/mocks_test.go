// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ddosprotection_test

import (
	"faraway/cmd/server/ddosprotection"
	"faraway/internal/pow"
	"net"
	"sync"
	"time"
)

// Ensure, that ConnectionMock does implement ddosprotection.Connection.
// If this is not the case, regenerate this file with moq.
var _ ddosprotection.Connection = &ConnectionMock{}

// ConnectionMock is a mock implementation of ddosprotection.Connection.
//
//	func TestSomethingThatUsesConnection(t *testing.T) {
//
//		// make and configure a mocked ddosprotection.Connection
//		mockedConnection := &ConnectionMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			LocalAddrFunc: func() net.Addr {
//				panic("mock out the LocalAddr method")
//			},
//			ReadFunc: func(b []byte) (int, error) {
//				panic("mock out the Read method")
//			},
//			RemoteAddrFunc: func() net.Addr {
//				panic("mock out the RemoteAddr method")
//			},
//			SetDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetDeadline method")
//			},
//			SetReadDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetReadDeadline method")
//			},
//			SetWriteDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetWriteDeadline method")
//			},
//			WriteFunc: func(b []byte) (int, error) {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedConnection in code that requires ddosprotection.Connection
//		// and then make assertions.
//
//	}
type ConnectionMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// LocalAddrFunc mocks the LocalAddr method.
	LocalAddrFunc func() net.Addr

	// ReadFunc mocks the Read method.
	ReadFunc func(b []byte) (int, error)

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() net.Addr

	// SetDeadlineFunc mocks the SetDeadline method.
	SetDeadlineFunc func(t time.Time) error

	// SetReadDeadlineFunc mocks the SetReadDeadline method.
	SetReadDeadlineFunc func(t time.Time) error

	// SetWriteDeadlineFunc mocks the SetWriteDeadline method.
	SetWriteDeadlineFunc func(t time.Time) error

	// WriteFunc mocks the Write method.
	WriteFunc func(b []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// LocalAddr holds details about calls to the LocalAddr method.
		LocalAddr []struct {
		}
		// Read holds details about calls to the Read method.
		Read []struct {
			// B is the b argument value.
			B []byte
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
		// SetDeadline holds details about calls to the SetDeadline method.
		SetDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// SetReadDeadline holds details about calls to the SetReadDeadline method.
		SetReadDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// SetWriteDeadline holds details about calls to the SetWriteDeadline method.
		SetWriteDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// B is the b argument value.
			B []byte
		}
	}
	lockClose            sync.RWMutex
	lockLocalAddr        sync.RWMutex
	lockRead             sync.RWMutex
	lockRemoteAddr       sync.RWMutex
	lockSetDeadline      sync.RWMutex
	lockSetReadDeadline  sync.RWMutex
	lockSetWriteDeadline sync.RWMutex
	lockWrite            sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ConnectionMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ConnectionMock.CloseFunc: method is nil but Connection.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedConnection.CloseCalls())
func (mock *ConnectionMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// LocalAddr calls LocalAddrFunc.
func (mock *ConnectionMock) LocalAddr() net.Addr {
	if mock.LocalAddrFunc == nil {
		panic("ConnectionMock.LocalAddrFunc: method is nil but Connection.LocalAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLocalAddr.Lock()
	mock.calls.LocalAddr = append(mock.calls.LocalAddr, callInfo)
	mock.lockLocalAddr.Unlock()
	return mock.LocalAddrFunc()
}

// LocalAddrCalls gets all the calls that were made to LocalAddr.
// Check the length with:
//
//	len(mockedConnection.LocalAddrCalls())
func (mock *ConnectionMock) LocalAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLocalAddr.RLock()
	calls = mock.calls.LocalAddr
	mock.lockLocalAddr.RUnlock()
	return calls
}

// Read calls ReadFunc.
func (mock *ConnectionMock) Read(b []byte) (int, error) {
	if mock.ReadFunc == nil {
		panic("ConnectionMock.ReadFunc: method is nil but Connection.Read was just called")
	}
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(b)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedConnection.ReadCalls())
func (mock *ConnectionMock) ReadCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *ConnectionMock) RemoteAddr() net.Addr {
	if mock.RemoteAddrFunc == nil {
		panic("ConnectionMock.RemoteAddrFunc: method is nil but Connection.RemoteAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedConnection.RemoteAddrCalls())
func (mock *ConnectionMock) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}

// SetDeadline calls SetDeadlineFunc.
func (mock *ConnectionMock) SetDeadline(t time.Time) error {
	if mock.SetDeadlineFunc == nil {
		panic("ConnectionMock.SetDeadlineFunc: method is nil but Connection.SetDeadline was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetDeadline.Lock()
	mock.calls.SetDeadline = append(mock.calls.SetDeadline, callInfo)
	mock.lockSetDeadline.Unlock()
	return mock.SetDeadlineFunc(t)
}

// SetDeadlineCalls gets all the calls that were made to SetDeadline.
// Check the length with:
//
//	len(mockedConnection.SetDeadlineCalls())
func (mock *ConnectionMock) SetDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetDeadline.RLock()
	calls = mock.calls.SetDeadline
	mock.lockSetDeadline.RUnlock()
	return calls
}

// SetReadDeadline calls SetReadDeadlineFunc.
func (mock *ConnectionMock) SetReadDeadline(t time.Time) error {
	if mock.SetReadDeadlineFunc == nil {
		panic("ConnectionMock.SetReadDeadlineFunc: method is nil but Connection.SetReadDeadline was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetReadDeadline.Lock()
	mock.calls.SetReadDeadline = append(mock.calls.SetReadDeadline, callInfo)
	mock.lockSetReadDeadline.Unlock()
	return mock.SetReadDeadlineFunc(t)
}

// SetReadDeadlineCalls gets all the calls that were made to SetReadDeadline.
// Check the length with:
//
//	len(mockedConnection.SetReadDeadlineCalls())
func (mock *ConnectionMock) SetReadDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetReadDeadline.RLock()
	calls = mock.calls.SetReadDeadline
	mock.lockSetReadDeadline.RUnlock()
	return calls
}

// SetWriteDeadline calls SetWriteDeadlineFunc.
func (mock *ConnectionMock) SetWriteDeadline(t time.Time) error {
	if mock.SetWriteDeadlineFunc == nil {
		panic("ConnectionMock.SetWriteDeadlineFunc: method is nil but Connection.SetWriteDeadline was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetWriteDeadline.Lock()
	mock.calls.SetWriteDeadline = append(mock.calls.SetWriteDeadline, callInfo)
	mock.lockSetWriteDeadline.Unlock()
	return mock.SetWriteDeadlineFunc(t)
}

// SetWriteDeadlineCalls gets all the calls that were made to SetWriteDeadline.
// Check the length with:
//
//	len(mockedConnection.SetWriteDeadlineCalls())
func (mock *ConnectionMock) SetWriteDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetWriteDeadline.RLock()
	calls = mock.calls.SetWriteDeadline
	mock.lockSetWriteDeadline.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *ConnectionMock) Write(b []byte) (int, error) {
	if mock.WriteFunc == nil {
		panic("ConnectionMock.WriteFunc: method is nil but Connection.Write was just called")
	}
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	return mock.WriteFunc(b)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedConnection.WriteCalls())
func (mock *ConnectionMock) WriteCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}

// Ensure, that TCPServerHandlerMock does implement ddosprotection.TCPServerHandler.
// If this is not the case, regenerate this file with moq.
var _ ddosprotection.TCPServerHandler = &TCPServerHandlerMock{}

// TCPServerHandlerMock is a mock implementation of ddosprotection.TCPServerHandler.
//
//	func TestSomethingThatUsesTCPServerHandler(t *testing.T) {
//
//		// make and configure a mocked ddosprotection.TCPServerHandler
//		mockedTCPServerHandler := &TCPServerHandlerMock{
//			HandleConnectionFunc: func(conn net.Conn) error {
//				panic("mock out the HandleConnection method")
//			},
//		}
//
//		// use mockedTCPServerHandler in code that requires ddosprotection.TCPServerHandler
//		// and then make assertions.
//
//	}
type TCPServerHandlerMock struct {
	// HandleConnectionFunc mocks the HandleConnection method.
	HandleConnectionFunc func(conn net.Conn) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleConnection holds details about calls to the HandleConnection method.
		HandleConnection []struct {
			// Conn is the conn argument value.
			Conn net.Conn
		}
	}
	lockHandleConnection sync.RWMutex
}

// HandleConnection calls HandleConnectionFunc.
func (mock *TCPServerHandlerMock) HandleConnection(conn net.Conn) error {
	if mock.HandleConnectionFunc == nil {
		panic("TCPServerHandlerMock.HandleConnectionFunc: method is nil but TCPServerHandler.HandleConnection was just called")
	}
	callInfo := struct {
		Conn net.Conn
	}{
		Conn: conn,
	}
	mock.lockHandleConnection.Lock()
	mock.calls.HandleConnection = append(mock.calls.HandleConnection, callInfo)
	mock.lockHandleConnection.Unlock()
	return mock.HandleConnectionFunc(conn)
}

// HandleConnectionCalls gets all the calls that were made to HandleConnection.
// Check the length with:
//
//	len(mockedTCPServerHandler.HandleConnectionCalls())
func (mock *TCPServerHandlerMock) HandleConnectionCalls() []struct {
	Conn net.Conn
} {
	var calls []struct {
		Conn net.Conn
	}
	mock.lockHandleConnection.RLock()
	calls = mock.calls.HandleConnection
	mock.lockHandleConnection.RUnlock()
	return calls
}

// Ensure, that POWGeneratorMock does implement ddosprotection.POWGenerator.
// If this is not the case, regenerate this file with moq.
var _ ddosprotection.POWGenerator = &POWGeneratorMock{}

// POWGeneratorMock is a mock implementation of ddosprotection.POWGenerator.
//
//	func TestSomethingThatUsesPOWGenerator(t *testing.T) {
//
//		// make and configure a mocked ddosprotection.POWGenerator
//		mockedPOWGenerator := &POWGeneratorMock{
//			GenerateChallengeFunc: func() (pow.Challenge, error) {
//				panic("mock out the GenerateChallenge method")
//			},
//		}
//
//		// use mockedPOWGenerator in code that requires ddosprotection.POWGenerator
//		// and then make assertions.
//
//	}
type POWGeneratorMock struct {
	// GenerateChallengeFunc mocks the GenerateChallenge method.
	GenerateChallengeFunc func() (pow.Challenge, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateChallenge holds details about calls to the GenerateChallenge method.
		GenerateChallenge []struct {
		}
	}
	lockGenerateChallenge sync.RWMutex
}

// GenerateChallenge calls GenerateChallengeFunc.
func (mock *POWGeneratorMock) GenerateChallenge() (pow.Challenge, error) {
	if mock.GenerateChallengeFunc == nil {
		panic("POWGeneratorMock.GenerateChallengeFunc: method is nil but POWGenerator.GenerateChallenge was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGenerateChallenge.Lock()
	mock.calls.GenerateChallenge = append(mock.calls.GenerateChallenge, callInfo)
	mock.lockGenerateChallenge.Unlock()
	return mock.GenerateChallengeFunc()
}

// GenerateChallengeCalls gets all the calls that were made to GenerateChallenge.
// Check the length with:
//
//	len(mockedPOWGenerator.GenerateChallengeCalls())
func (mock *POWGeneratorMock) GenerateChallengeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGenerateChallenge.RLock()
	calls = mock.calls.GenerateChallenge
	mock.lockGenerateChallenge.RUnlock()
	return calls
}

// Ensure, that POWVerifierMock does implement ddosprotection.POWVerifier.
// If this is not the case, regenerate this file with moq.
var _ ddosprotection.POWVerifier = &POWVerifierMock{}

// POWVerifierMock is a mock implementation of ddosprotection.POWVerifier.
//
//	func TestSomethingThatUsesPOWVerifier(t *testing.T) {
//
//		// make and configure a mocked ddosprotection.POWVerifier
//		mockedPOWVerifier := &POWVerifierMock{
//			VerifySolutionFunc: func(challenge pow.Challenge, nonce pow.Nonce) bool {
//				panic("mock out the VerifySolution method")
//			},
//		}
//
//		// use mockedPOWVerifier in code that requires ddosprotection.POWVerifier
//		// and then make assertions.
//
//	}
type POWVerifierMock struct {
	// VerifySolutionFunc mocks the VerifySolution method.
	VerifySolutionFunc func(challenge pow.Challenge, nonce pow.Nonce) bool

	// calls tracks calls to the methods.
	calls struct {
		// VerifySolution holds details about calls to the VerifySolution method.
		VerifySolution []struct {
			// Challenge is the challenge argument value.
			Challenge pow.Challenge
			// Nonce is the nonce argument value.
			Nonce pow.Nonce
		}
	}
	lockVerifySolution sync.RWMutex
}

// VerifySolution calls VerifySolutionFunc.
func (mock *POWVerifierMock) VerifySolution(challenge pow.Challenge, nonce pow.Nonce) bool {
	if mock.VerifySolutionFunc == nil {
		panic("POWVerifierMock.VerifySolutionFunc: method is nil but POWVerifier.VerifySolution was just called")
	}
	callInfo := struct {
		Challenge pow.Challenge
		Nonce     pow.Nonce
	}{
		Challenge: challenge,
		Nonce:     nonce,
	}
	mock.lockVerifySolution.Lock()
	mock.calls.VerifySolution = append(mock.calls.VerifySolution, callInfo)
	mock.lockVerifySolution.Unlock()
	return mock.VerifySolutionFunc(challenge, nonce)
}

// VerifySolutionCalls gets all the calls that were made to VerifySolution.
// Check the length with:
//
//	len(mockedPOWVerifier.VerifySolutionCalls())
func (mock *POWVerifierMock) VerifySolutionCalls() []struct {
	Challenge pow.Challenge
	Nonce     pow.Nonce
} {
	var calls []struct {
		Challenge pow.Challenge
		Nonce     pow.Nonce
	}
	mock.lockVerifySolution.RLock()
	calls = mock.calls.VerifySolution
	mock.lockVerifySolution.RUnlock()
	return calls
}

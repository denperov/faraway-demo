// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package quotehandler_test

import (
	"faraway/cmd/server/quotehandler"
	"net"
	"sync"
	"time"
)

// Ensure, that ConnectionMock does implement quotehandler.Connection.
// If this is not the case, regenerate this file with moq.
var _ quotehandler.Connection = &ConnectionMock{}

// ConnectionMock is a mock implementation of quotehandler.Connection.
//
//	func TestSomethingThatUsesConnection(t *testing.T) {
//
//		// make and configure a mocked quotehandler.Connection
//		mockedConnection := &ConnectionMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			LocalAddrFunc: func() net.Addr {
//				panic("mock out the LocalAddr method")
//			},
//			ReadFunc: func(b []byte) (int, error) {
//				panic("mock out the Read method")
//			},
//			RemoteAddrFunc: func() net.Addr {
//				panic("mock out the RemoteAddr method")
//			},
//			SetDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetDeadline method")
//			},
//			SetReadDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetReadDeadline method")
//			},
//			SetWriteDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetWriteDeadline method")
//			},
//			WriteFunc: func(b []byte) (int, error) {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedConnection in code that requires quotehandler.Connection
//		// and then make assertions.
//
//	}
type ConnectionMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// LocalAddrFunc mocks the LocalAddr method.
	LocalAddrFunc func() net.Addr

	// ReadFunc mocks the Read method.
	ReadFunc func(b []byte) (int, error)

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() net.Addr

	// SetDeadlineFunc mocks the SetDeadline method.
	SetDeadlineFunc func(t time.Time) error

	// SetReadDeadlineFunc mocks the SetReadDeadline method.
	SetReadDeadlineFunc func(t time.Time) error

	// SetWriteDeadlineFunc mocks the SetWriteDeadline method.
	SetWriteDeadlineFunc func(t time.Time) error

	// WriteFunc mocks the Write method.
	WriteFunc func(b []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// LocalAddr holds details about calls to the LocalAddr method.
		LocalAddr []struct {
		}
		// Read holds details about calls to the Read method.
		Read []struct {
			// B is the b argument value.
			B []byte
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
		// SetDeadline holds details about calls to the SetDeadline method.
		SetDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// SetReadDeadline holds details about calls to the SetReadDeadline method.
		SetReadDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// SetWriteDeadline holds details about calls to the SetWriteDeadline method.
		SetWriteDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// B is the b argument value.
			B []byte
		}
	}
	lockClose            sync.RWMutex
	lockLocalAddr        sync.RWMutex
	lockRead             sync.RWMutex
	lockRemoteAddr       sync.RWMutex
	lockSetDeadline      sync.RWMutex
	lockSetReadDeadline  sync.RWMutex
	lockSetWriteDeadline sync.RWMutex
	lockWrite            sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ConnectionMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ConnectionMock.CloseFunc: method is nil but Connection.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedConnection.CloseCalls())
func (mock *ConnectionMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// LocalAddr calls LocalAddrFunc.
func (mock *ConnectionMock) LocalAddr() net.Addr {
	if mock.LocalAddrFunc == nil {
		panic("ConnectionMock.LocalAddrFunc: method is nil but Connection.LocalAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLocalAddr.Lock()
	mock.calls.LocalAddr = append(mock.calls.LocalAddr, callInfo)
	mock.lockLocalAddr.Unlock()
	return mock.LocalAddrFunc()
}

// LocalAddrCalls gets all the calls that were made to LocalAddr.
// Check the length with:
//
//	len(mockedConnection.LocalAddrCalls())
func (mock *ConnectionMock) LocalAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLocalAddr.RLock()
	calls = mock.calls.LocalAddr
	mock.lockLocalAddr.RUnlock()
	return calls
}

// Read calls ReadFunc.
func (mock *ConnectionMock) Read(b []byte) (int, error) {
	if mock.ReadFunc == nil {
		panic("ConnectionMock.ReadFunc: method is nil but Connection.Read was just called")
	}
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(b)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedConnection.ReadCalls())
func (mock *ConnectionMock) ReadCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *ConnectionMock) RemoteAddr() net.Addr {
	if mock.RemoteAddrFunc == nil {
		panic("ConnectionMock.RemoteAddrFunc: method is nil but Connection.RemoteAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedConnection.RemoteAddrCalls())
func (mock *ConnectionMock) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}

// SetDeadline calls SetDeadlineFunc.
func (mock *ConnectionMock) SetDeadline(t time.Time) error {
	if mock.SetDeadlineFunc == nil {
		panic("ConnectionMock.SetDeadlineFunc: method is nil but Connection.SetDeadline was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetDeadline.Lock()
	mock.calls.SetDeadline = append(mock.calls.SetDeadline, callInfo)
	mock.lockSetDeadline.Unlock()
	return mock.SetDeadlineFunc(t)
}

// SetDeadlineCalls gets all the calls that were made to SetDeadline.
// Check the length with:
//
//	len(mockedConnection.SetDeadlineCalls())
func (mock *ConnectionMock) SetDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetDeadline.RLock()
	calls = mock.calls.SetDeadline
	mock.lockSetDeadline.RUnlock()
	return calls
}

// SetReadDeadline calls SetReadDeadlineFunc.
func (mock *ConnectionMock) SetReadDeadline(t time.Time) error {
	if mock.SetReadDeadlineFunc == nil {
		panic("ConnectionMock.SetReadDeadlineFunc: method is nil but Connection.SetReadDeadline was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetReadDeadline.Lock()
	mock.calls.SetReadDeadline = append(mock.calls.SetReadDeadline, callInfo)
	mock.lockSetReadDeadline.Unlock()
	return mock.SetReadDeadlineFunc(t)
}

// SetReadDeadlineCalls gets all the calls that were made to SetReadDeadline.
// Check the length with:
//
//	len(mockedConnection.SetReadDeadlineCalls())
func (mock *ConnectionMock) SetReadDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetReadDeadline.RLock()
	calls = mock.calls.SetReadDeadline
	mock.lockSetReadDeadline.RUnlock()
	return calls
}

// SetWriteDeadline calls SetWriteDeadlineFunc.
func (mock *ConnectionMock) SetWriteDeadline(t time.Time) error {
	if mock.SetWriteDeadlineFunc == nil {
		panic("ConnectionMock.SetWriteDeadlineFunc: method is nil but Connection.SetWriteDeadline was just called")
	}
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetWriteDeadline.Lock()
	mock.calls.SetWriteDeadline = append(mock.calls.SetWriteDeadline, callInfo)
	mock.lockSetWriteDeadline.Unlock()
	return mock.SetWriteDeadlineFunc(t)
}

// SetWriteDeadlineCalls gets all the calls that were made to SetWriteDeadline.
// Check the length with:
//
//	len(mockedConnection.SetWriteDeadlineCalls())
func (mock *ConnectionMock) SetWriteDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetWriteDeadline.RLock()
	calls = mock.calls.SetWriteDeadline
	mock.lockSetWriteDeadline.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *ConnectionMock) Write(b []byte) (int, error) {
	if mock.WriteFunc == nil {
		panic("ConnectionMock.WriteFunc: method is nil but Connection.Write was just called")
	}
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	return mock.WriteFunc(b)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedConnection.WriteCalls())
func (mock *ConnectionMock) WriteCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}

// Ensure, that QuoteStorageMock does implement quotehandler.QuoteStorage.
// If this is not the case, regenerate this file with moq.
var _ quotehandler.QuoteStorage = &QuoteStorageMock{}

// QuoteStorageMock is a mock implementation of quotehandler.QuoteStorage.
//
//	func TestSomethingThatUsesQuoteStorage(t *testing.T) {
//
//		// make and configure a mocked quotehandler.QuoteStorage
//		mockedQuoteStorage := &QuoteStorageMock{
//			GetQuoteFunc: func() (string, error) {
//				panic("mock out the GetQuote method")
//			},
//		}
//
//		// use mockedQuoteStorage in code that requires quotehandler.QuoteStorage
//		// and then make assertions.
//
//	}
type QuoteStorageMock struct {
	// GetQuoteFunc mocks the GetQuote method.
	GetQuoteFunc func() (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetQuote holds details about calls to the GetQuote method.
		GetQuote []struct {
		}
	}
	lockGetQuote sync.RWMutex
}

// GetQuote calls GetQuoteFunc.
func (mock *QuoteStorageMock) GetQuote() (string, error) {
	if mock.GetQuoteFunc == nil {
		panic("QuoteStorageMock.GetQuoteFunc: method is nil but QuoteStorage.GetQuote was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetQuote.Lock()
	mock.calls.GetQuote = append(mock.calls.GetQuote, callInfo)
	mock.lockGetQuote.Unlock()
	return mock.GetQuoteFunc()
}

// GetQuoteCalls gets all the calls that were made to GetQuote.
// Check the length with:
//
//	len(mockedQuoteStorage.GetQuoteCalls())
func (mock *QuoteStorageMock) GetQuoteCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetQuote.RLock()
	calls = mock.calls.GetQuote
	mock.lockGetQuote.RUnlock()
	return calls
}
